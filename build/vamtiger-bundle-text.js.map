{"version":3,"file":"vamtiger-bundle-text.js","sources":["../source/types.ts","../source/get-bundle-export.ts","../source/vamtiger-bundle-text.ts"],"sourcesContent":["export enum StringConstant {\n    nothing = '',\n    newline = '\\n',\n    space = ' ',\n    slash = '/',\n    period = '.',\n    and = '&&'\n}\n\nexport enum CommandlineArguments {\n    folder = 'folder',\n    name = 'name',\n    type = 'type'\n}\n\nexport enum ErrorMessage {\n    noName = 'No bundle name defined',\n    noBundle = 'No bundle created'\n}\n\nexport enum BundleType {\n    ts = 'ts',\n    js = 'js',\n    json = 'json'\n}\n\nexport interface IGetBundleExport {\n    folder: string;\n    name: string;\n    type: BundleType;\n}\n\nexport interface IBundleExport {\n    [key: string]: string;\n}\n\nexport const regex = {\n    leadingSlash: new RegExp(`^${StringConstant.slash}`)\n}","import { resolve as resolvePath } from 'path';\nimport getFileText from 'vamtiger-get-file-text';\nimport createFile from 'vamtiger-create-file';\nimport getFolderContent, { ClassifiedDirectoryContent } from 'vamtiger-get-directory-content-recursive';\nimport {\n    IGetBundleExport,\n    IBundleExport,\n    StringConstant,\n    BundleType,\n    ErrorMessage,\n    regex\n} from './types';\n\nconst { stringify } = JSON;\nconst { nothing } = StringConstant;\nconst { noBundle } = ErrorMessage;\nconst { leadingSlash } = regex;\n\nexport default async function ({ folder, name, type }: IGetBundleExport) {\n    const { file: filePaths } = await getFolderContent({\n        path: folder,\n        classified: true\n    }) as ClassifiedDirectoryContent;\n    const bundlePath = resolvePath(\n        folder,\n        `${name}.${type}`\n    );\n    const bundleExport = await Promise\n        .all((filePaths as string[]).map(async filePath => ({ [filePath.replace(folder, nothing).replace(leadingSlash, nothing)]: await getFileText(filePath)}) as IBundleExport))\n        .then(bundleExports => bundleExports.reduce((bundleExport, currentBundleExport) => ({...bundleExport, ...currentBundleExport}), {} as IBundleExport));\n    const bundleExportStatement = type === BundleType.json && stringify(bundleExport)\n        || type === BundleType.js && `module.exports = ${stringify(bundleExport)}`\n        || type === BundleType.ts && `export default ${stringify(bundleExport)}`;\n\n    if (!bundleExportStatement) {\n        throw new Error(noBundle);\n    }\n\n    await createFile(bundlePath, bundleExportStatement);\n\n    return bundleExportStatement;\n}","import Args from 'vamtiger-argv/build/main';\nimport {\n    CommandlineArguments,\n    IGetBundleExport,\n    ErrorMessage,\n    BundleType\n} from './types';\nimport getBundleExport from './get-bundle-export';\n\nconst args = new Args();\nconst { cwd } = process;\nconst folder = args.has(CommandlineArguments.folder) && args.get(CommandlineArguments.folder) || cwd();\nconst name = args.has(CommandlineArguments.name) && args.get(CommandlineArguments.name);\nconst type = (args.has(CommandlineArguments.type) && args.get(CommandlineArguments.type) || BundleType.ts) as BundleType;\nconst { noName } = ErrorMessage;\n\nif (!name) {\n    throw new Error(noName);\n}\n\nbundleText({ folder, name, type });\n\nasync function bundleText({ folder, name, type }: IGetBundleExport) {\n    const bundleText = await getBundleExport({ folder, name, type })\n        .catch(handleError);\n\n    return bundleText;\n}\n\nfunction handleError(error: Error) {\n    console.error(error.message);\n    console.error(error.stack);\n    process.exit();\n}\n\nexport default bundleText;"],"names":["StringConstant","CommandlineArguments","ErrorMessage","BundleType","regex","leadingSlash","RegExp","slash","stringify","JSON","nothing","noBundle","async","folder","name","type","file","filePaths","getFolderContent","path","classified","bundlePath","resolvePath","bundleExport","Promise","all","map","filePath","[object Object]","replace","getFileText","then","bundleExports","reduce","currentBundleExport","bundleExportStatement","json","js","ts","Error","createFile","args","Args","cwd","process","has","get","noName","bundleText","getBundleExport","catch","handleError","error","console","message","stack","exit"],"mappings":"qGAAYA,eASAC,qBAMAC,aAKAC,4SApBZ,SAAYH,GACRA,aACAA,eACAA,YACAA,YACAA,aACAA,WANJ,CAAYA,iBAAAA,oBASZ,SAAYC,GACRA,kBACAA,cACAA,cAHJ,CAAYA,uBAAAA,0BAMZ,SAAYC,GACRA,kCACAA,+BAFJ,CAAYA,eAAAA,kBAKZ,SAAYC,GACRA,UACAA,UACAA,cAHJ,CAAYA,aAAAA,gBAgBZ,MAAaC,OACTC,aAAc,IAAIC,WAAWN,eAAeO,WCxB1CC,UAAEA,WAAcC,MAChBC,QAAEA,SAAYV,gBACdW,SAAEA,UAAaT,cACfG,aAAEA,cAAiBD,MAEzBQ,gCAA+BC,OAAEA,EAAMC,KAAEA,EAAIC,KAAEA,IAC3C,MAAQC,KAAMC,SAAoBC,kBAC9BC,KAAMN,EACNO,YAAY,IAEVC,EAAaC,aACfT,KACGC,KAAQC,KAETQ,QAAqBC,QACtBC,IAAKR,EAAuBS,IAAId,MAAMe,KAAeC,CAACD,EAASE,QAAQhB,EAAQH,SAASmB,QAAQxB,aAAcK,gBAAiBoB,YAAYH,OAC3II,KAAKC,GAAiBA,EAAcC,OAAO,CAACV,EAAcW,qBAA6BX,EAAiBW,QACvGC,EAAwBpB,IAASZ,WAAWiC,MAAQ5B,UAAUe,IAC7DR,IAASZ,WAAWkC,wBAA0B7B,UAAUe,MACxDR,IAASZ,WAAWmC,sBAAwB9B,UAAUe,KAE7D,IAAKY,EACD,MAAM,IAAII,MAAM5B,UAKpB,aAFM6B,WAAWnB,EAAYc,GAEtBA,EC/BX,MAAMM,KAAO,IAAIC,MACXC,IAAEA,KAAQC,QACV/B,OAAS4B,KAAKI,IAAI5C,qBAAqBY,SAAW4B,KAAKK,IAAI7C,qBAAqBY,SAAW8B,MAC3F7B,KAAO2B,KAAKI,IAAI5C,qBAAqBa,OAAS2B,KAAKK,IAAI7C,qBAAqBa,MAC5EC,KAAQ0B,KAAKI,IAAI5C,qBAAqBc,OAAS0B,KAAKK,IAAI7C,qBAAqBc,OAASZ,WAAWmC,IACjGS,OAAEA,QAAW7C,aAEnB,IAAKY,KACD,MAAM,IAAIyB,MAAMQ,QAKpBnC,eAAeoC,YAAWnC,OAAEA,EAAMC,KAAEA,EAAIC,KAAEA,IAItC,aAHyBkC,iBAAkBpC,OAAAA,EAAQC,KAAAA,EAAMC,KAAAA,IACpDmC,MAAMC,aAKf,SAASA,YAAYC,GACjBC,QAAQD,MAAMA,EAAME,SACpBD,QAAQD,MAAMA,EAAMG,OACpBX,QAAQY,OAZZR,YAAanC,OAAAA,OAAQC,KAAAA,KAAMC,KAAAA"}